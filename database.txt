
-- SHUTTLEUP SUPABASE SCHEMA
-- Professional Badminton Tournament Management

-- 1. EXTENSIONS
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 2. TABLES

-- Profiles Table (Extended Auth)
CREATE TABLE public.profiles (
    id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
    id_num SERIAL,
    username TEXT UNIQUE NOT NULL,
    full_name TEXT NOT NULL,
    email TEXT,
    role TEXT NOT NULL DEFAULT 'player' CHECK (role IN ('superadmin', 'admin', 'player', 'scorer')),
    credits INTEGER NOT NULL DEFAULT 0 CHECK (credits >= 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Tournaments Table
CREATE TABLE public.tournaments (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    id_num SERIAL,
    name TEXT NOT NULL,
    description TEXT,
    organizer_id UUID REFERENCES public.profiles(id) NOT NULL,
    status TEXT NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'published', 'finished', 'cancelled')),
    cost_to_host INTEGER NOT NULL DEFAULT 200,
    is_locked BOOLEAN DEFAULT FALSE,
    location_name TEXT,
    latitude DOUBLE PRECISION,
    longitude DOUBLE PRECISION,
    start_date DATE,
    rules_handbook TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Teams Table
CREATE TABLE public.teams (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    id_num SERIAL,
    tournament_id UUID REFERENCES public.tournaments(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    points INTEGER DEFAULT 0,
    wins INTEGER DEFAULT 0,
    losses INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Matches Table
CREATE TABLE public.matches (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    id_num SERIAL,
    tournament_id UUID REFERENCES public.tournaments(id) ON DELETE CASCADE NOT NULL,
    team1_id UUID REFERENCES public.teams(id) ON DELETE CASCADE NOT NULL,
    team2_id UUID REFERENCES public.teams(id) ON DELETE CASCADE NOT NULL,
    score1 INTEGER DEFAULT 0,
    score2 INTEGER DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'live', 'completed')),
    scheduled_at TIMESTAMP WITH TIME ZONE NOT NULL,
    completed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Credit Logs Table
CREATE TABLE public.credit_logs (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    amount INTEGER NOT NULL,
    action_type TEXT NOT NULL,
    description TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 3. FUNCTIONS & TRIGGERS

-- Automatically create profile on signup
-- Prioritizes metadata.username, falls back to local-part of email
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
    final_username TEXT;
BEGIN
    final_username := LOWER(COALESCE(NEW.raw_user_meta_data->>'username', split_part(NEW.email, '@', 1)));
    
    INSERT INTO public.profiles (id, username, full_name, email, role)
    VALUES (
        NEW.id,
        final_username,
        COALESCE(NEW.raw_user_meta_data->>'full_name', 'Unnamed User'),
        NULL, -- We don't store the @example.com shim in the public profile email field
        COALESCE(NEW.raw_user_meta_data->>'role', 'player')
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Re-apply trigger (Delete if exists to avoid duplication)
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Atomic function to update user credits and log the action
CREATE OR REPLACE FUNCTION public.update_user_credits(
    target_user_id UUID,
    amount_change INTEGER,
    log_description TEXT,
    log_action TEXT
)
RETURNS VOID AS $$
BEGIN
    IF amount_change < 0 AND (SELECT credits FROM public.profiles WHERE id = target_user_id) < ABS(amount_change) THEN
        RAISE EXCEPTION 'Insufficient credits';
    END IF;

    UPDATE public.profiles
    SET credits = credits + amount_change
    WHERE id = target_user_id;

    INSERT INTO public.credit_logs (user_id, amount, action_type, description)
    VALUES (target_user_id, amount_change, log_action, log_description);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 4. ROW LEVEL SECURITY (RLS)

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tournaments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.teams ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.matches ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.credit_logs ENABLE ROW LEVEL SECURITY;

-- Profiles Policies
CREATE POLICY "Public profiles are viewable by everyone" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "SuperAdmins can update all profiles" ON public.profiles FOR ALL USING (
    (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'superadmin'
);

-- Tournament Policies
CREATE POLICY "Tournaments are viewable by everyone" ON public.tournaments FOR SELECT USING (true);
CREATE POLICY "Admins can create tournaments" ON public.tournaments FOR INSERT WITH CHECK (
    (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('admin', 'superadmin')
);
CREATE POLICY "Organizers can update own tournament" ON public.tournaments FOR UPDATE USING (
    organizer_id = auth.uid() OR (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'superadmin'
);

-- Teams Policies
CREATE POLICY "Teams are viewable by everyone" ON public.teams FOR SELECT USING (true);
CREATE POLICY "Organizers can manage teams" ON public.teams FOR ALL USING (
    EXISTS (
        SELECT 1 FROM public.tournaments 
        WHERE tournaments.id = teams.tournament_id 
        AND (tournaments.organizer_id = auth.uid() OR (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'superadmin')
    )
);

-- Matches Policies
CREATE POLICY "Matches are viewable by everyone" ON public.matches FOR SELECT USING (true);
CREATE POLICY "Scorers and Organizers can manage matches" ON public.matches FOR ALL USING (
    EXISTS (
        SELECT 1 FROM public.tournaments 
        WHERE tournaments.id = matches.tournament_id 
        AND (
            tournaments.organizer_id = auth.uid() 
            OR (SELECT role FROM public.profiles WHERE id = auth.uid()) IN ('superadmin', 'scorer')
        )
    )
);

-- Credit Logs Policies
CREATE POLICY "Users can view own logs" ON public.credit_logs FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "SuperAdmins can view all logs" ON public.credit_logs FOR SELECT USING (
    (SELECT role FROM public.profiles WHERE id = auth.uid()) = 'superadmin'
);

-- Enable Realtime
ALTER PUBLICATION supabase_realtime ADD TABLE matches;
ALTER PUBLICATION supabase_realtime ADD TABLE tournaments;
ALTER PUBLICATION supabase_realtime ADD TABLE teams;
ALTER PUBLICATION supabase_realtime ADD TABLE profiles;
